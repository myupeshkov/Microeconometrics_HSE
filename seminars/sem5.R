# --------
# Потанин Богдан Станиславович
# Микроэконометрика в R :)
# Семинар 5. Системы бинарных уравнений
# --------

# Отключим scientific notation
options(scipen = 999)

#---------------------------------------------------
# Симуляция данных
#---------------------------------------------------

library("mvtnorm")                                   # многомерное нормальное
# распределение

# Для удобства представим, что мы симулируем процесс,
# определяющий дефолт по кредиту и факт наличия
# стабильной работы

# Симулируем данные
set.seed(123)                                        # для воспроизводимости
n <- 10000                                           # число индивидов в выборке
h <- data.frame(income = exp(rnorm(n, 10, 0.7)))     # доход
h$age = round(runif(n, 20, 100))                     # возраст
educ = t(rmultinom(n, 1, c(0.5, 0.3, 0.2)))          # уровень образования
h$educ_1 = as.numeric(educ[, 1] == 1)                # среднее образование
h$educ_2 = as.numeric(educ[, 2] == 1)                # среднее специальное образование
h$educ_3 <- as.numeric(educ[, 3] == 1)               # высшее образование
h$credit <- runif(n, 10000, 1000000)                 # объем кредита
h$marriage <- rbinom(n, 1, 0.7)                      # официальный брак

# Симулируем случайные ошибки из двумерного
# нормального распределения
rho <- -0.5                                          # корреляция между
# случайными ошибками уравнений
eps <- rmvnorm(n, 
               mean = c(0, 0), 
               sigma = matrix(c(1, rho, rho, 1), 
                              ncol = 2))
head(eps, 5)
eps1 <- eps[, 1]                                     # случайные ошибки уравнения дефолта
eps2 <- eps[, 2]                                     # случайные ошибки уравнения
# стабильной работы

# Зададим регрессоинные коэффициенты                                 
beta1 <- c(8, -0.7, -0.02,                           # оцениваемые регрессионные 
           0.0001, -0.1, -0.3,                       # коэффициенты уравнения дефолта
           -0.5, 0.001, -0.1)   

beta2 <- c(-5, 0.1, 0.2)                             # оцениваемые регрессионные 
# коэффициенты уравнения
# стабильной работы

# Для уравнения стабильной работы создадим
# линейный индекс
stable_li <- beta2[1] + beta2[2] * h$age + 
  beta2[3] * h$marriage
# латентную переменную
stable_star <- stable_li + eps2 
# зависимую переменную
h$stable <- as.numeric(stable_star >= 0)

# Для уравнения дефолта сформируем
# линейный индекс
default_li <- beta1[1] + 
  beta1[2] * log(h$income) +
  beta1[3] * h$age +
  beta1[4] * h$age ^ 2 +
  beta1[5] * h$educ_1 +
  beta1[6] * h$educ_2 +
  beta1[7] * h$educ_3 +
  beta1[8] * sqrt(h$credit) +
  beta1[9] * h$stable
# латентную переменную
default_star <- default_li + eps1
# зависимую переменную
h$default <- as.numeric(default_star >= 0)

# Итоговые данные
head(h, 10)

# --------------------------------------------
# Описание переменных:
# income    - доход
# age       - возраст
# educ_1    - среднее образование
# educ_2    - среднее специальное образование
# educ_3    - высшее образование
# credit    - объем кредита
# marriage  - состоит в браке
# default   - факт дефолта
# stable    - стабильная работа
# --------------------------------------------

#---------------------------------------------------
# Часть 1. Оценивание системы бинарных уравнений
#---------------------------------------------------

# -----
# Учимся:
# 1. Оценивать параметры системы бинарных уравнений
# 2. интерпретировать корреляцию между случайными ошибками
# -----

library("GJRM")                                         # оценивание систем
# бинарных уравнений
library("pbivnorm")                                     # двумерное нормальное распределение

# Оцениваем параметры модели
default_formula <- default ~ log(income) +              # записываем формулы линейного индекса
  age + educ_3               # для каждого из уравнений системы
stable_formula <- stable ~ age + marriage                   
model_bp <- gjrm(formula = list(default_formula,        # задаем лист, состоящий из 
                                stable_formula),        # обеих формул
                 data = h,
                 Model = "B",                           # указываем тип модели как систему
                 # бинанрных уравнений
                 margins = c("probit", "probit"),       # задаем маржинальные распределения
                 # случайных ошибок уравнений
                 BivD = "N")                            # задаем тип совместного распределения
# случайных ошибок (копулу)
summary(model_bp)                                       # посмотрим на результат

# Рассмотрим корреляцию между 
# случайными ошибками уравнений
rho_est <- model_bp$theta                               # оценка корреляции между случайными ошибками
data.frame("Rho real" = rho,                            # сравним истинное значение корреляции
           "Rho estimate" = rho_est)                    # с её оценкой
cov_est <- solve(model_bp$fit$hessian)                  # оценка асимптотической ковариационной матрицы
std_rho <- sqrt(cov_est["theta.star", "theta.star"])    # оценка стандартной ошибки оценки корреляции
p_value_rho <- 2 * min(pnorm(rho_est / std_rho),        # p-value теста о равенстве корреляции между
                       1- pnorm(rho_est / std_rho))     # случайными ошибками нулю
cov_u_est <- matrix(c(1, rho_est,                       # оценка ковариационной матрицы
                      rho_est, 1),                      # совместного распределения случайных ошибок
                    ncol = 2)

# ЗАДАНИЯ (* - средне, ** - сложно, *** - очень сложно)
# 1.1. Добавьте в уравнение занятости переменную на
#      квадратный корень из объема кредита и протестируйте
#      нулевую гипотезу о том, что уравнения дефолта и
#      стабильной работы можно оценивать раздельно
# 1.2. Повторите предыдущее задание заменив уравнение
#      стабильной работы на уравнение высшего образования,
#      предположив, что вероятность его получения 
#      зависит от возраста и возраста в квадрате.


#---------------------------------------------------
# Часть 2. Оценивание вероятностей
#---------------------------------------------------

# Получим оценки линейных индексов
default_li <- predict(model_bp, eq = 1)                 # уравнение дефолта
stable_li <- predict(model_bp, eq = 2)                  # уравнение стабильной работы

# Оценим для индивидов вероятность:
p_1 <- predict(model_bp,                                # дефолта           
               type = "response",
               eq = 1) 
p_1 <- pnorm(default_li)                                # альтернативный способ
p_2 <- predict(model_bp,                                # стабильной работы                 
               type = "response",
               eq = 2)
p_2 <- pnorm(stable_li)                                 # альтернативный способ

# Оценим вероятность того, что у индивида
# наступит дефолт и он будет работать на
# стабильной работе
p_1_2 <- pbivnorm(x = cbind(default_li,                 # аргументы функции распределения
                            stable_li),                 # двумерного нормального распределения,
                  # расположенные по строкам
                  rho = rho_est)                        # корреляция
head(p_1_2, 5)

# Оценим вероятность того у индивида
# наступит дефолт и он не будет работать
# на стабильной работе
p_1_n2 <- pbivnorm(x = cbind(default_li, -stable_li),   # аргументы функции распределения
                   # двумерного нормального распределения,
                   # расположенные по строкам
                   rho = -rho_est)
head(p_1_n2, 5)

# Пользуясь формулой условной вероятности
# оценим условные вероятности того, что
p_1_cond_2 <- p_1_2 / p_2                               # наступит дефолт при условии, что
# у индивида стабильная работа
head(p_1_cond_2, 5)
p_1_cond_n2 <- p_1_n2 / (1 - p_2)                       # наступит дефолт при условии, что
# у индивида не стабильная работа
head(p_1_cond_n2, 5)
# Сравним условные и безусловные вероятности
# успеха в первом уравнении
p_df <- data.frame(p_1,                                 # безусловная вероятности
                   p_1_cond_2, p_1_cond_n2)             # условная вероятность
colnames(p_df) = c("P(default = 1)", 
                   "P(default = 1 | stable = 1)", 
                   "P(default = 1 | stable = 0)")
head(p_df, 10)                                          # посмотрим на первые
# десять вероятностей

# ЗАДАНИЯ (* - средне, ** - сложно, *** - очень сложно)
# Рассмотрите следующий пример и выполните для него
# указанные нижена задания:
# 2.1.     Оцените вероятность того, что индивид с
#          вашими характеристиками
#          1)     готов платить за сохранение парка
#          2)     не готов платить за сохранение парка
#          3)     готов платить за сохранение парка и
#                 не посещал этот парк
#          4)     готов платить за сохранение парка, если
#                 он не посещал этот парк
#          5*)    готов платить за сохранение парка или
#                 посещал этот парк
#          6**)   готов платить за сохранение парка, если
#                 он или готов платить за сохранение парка
#                 но не посещал парк, или не готов платить,
#                 но посещал парк
#         Примечание: используйте аргумент newdata
#                     в функции predict()
# 2.2.    На уровне значимости 5% проверьте гипотезу о независимости
#         случайных ошибок уравнений готовности платить и 
#         посещения парка
#         1)     используя стандартную ошибку оценки
#                корреляции между случайными ошибками
#         2*)    используя LR тест
# 2.3.    Оцените предельный эффект возраста на 
#         вероятности из пункта 1.1.
#         1*)    используя численное дифференцирование
#         2**)   используя аналитические формулы для дифференцирования
# 2.4.    На уровне значимости 5% проверьте гипотезу о том, что
#         возраст не влияет ни на вероятность проявить готовность
#         платить, ни на вероятность посещения парка
#         1)     используя LR тест
#         2)     используя тест Вальда
# 2.5*.   На уровне значимости 5% при помощи LR теста проверьте
#         возможность оценивания общей модели для мужчин и женщин
# 2.6.    Руководствуясь информационными критериями выбирете
#         1*)    оптимальные маржинальные распределения 
#                для случайных ошибок
#         2**)   оптимальную копулу и маржинальные распределения
#                для случайных ошибок
# 2.7***. Запрограммируйте процедуру оценивания системы бинарных уравнений
#         с гетероскедастичной корреляцией между случайными ошибками
#         Подсказка: адаптируйте Сигмойдную функцию f(x) = 1 / (1 + exp(-x))
#                    для линейного индекса уравнения корреляции

#---------------------------------------------------
# Часть 3. Иерархические системы бинарных уравнений
#---------------------------------------------------

# Оцениваем параметры иерархической модели
default_formula <- default ~ log(income) + age +        # включаем стибильную работу в 
  educ_3 + stable            # уравнение дефолта
model_bp2 <- gjrm(formula = list(default_formula,       # задаем лист, состоящий из 
                                 stable_formula),       # обеих формул
                  data = h,
                  Model = "B",                          # указываем тип модели как систему
                  # бинанрных уравнений
                  margins = c("probit", "probit"),      # задаем маржинальные распределения
                  # случайных ошибок уравнений
                  BivD = "N")                           # задаем тип совместного распределения
# случайных ошибок (копулу)
summary(model_bp2)                                      # посмотрим на результат

# Создадим отдельного индивида
Boris <- data.frame(age = 30,
                    income = 5500, 
                    educ_3 = 1,
                    marriage = 0,
                    stable = 1)

# Оценим линейные индексы уравнений для Бориса
default_li <- predict(model_bp2, eq = 1, 
                      newdata = Boris)
stable_li <- predict(model_bp2, eq = 2, 
                     newdata = Boris)

# Оценим вероятности для Бориса
p_1 <- predict(model_bp2, eq = 1, type = "response",   # вероятность дефолта
               newdata = Boris)
p_2 <- predict(model_bp2, eq = 2, type = "response",   # вероятность стабильной
               newdata = Boris)                        # работы
p_1_2 <- pbivnorm(x = matrix(c(default_li, stable_li), # вероятность дефолта и
                             ncol = 2),                # стабильной работы
                  rho = rho_est)

# Оценим вероятность того, что у Бориса будет
# дефолт при условии, что он у него стабильная работа
p_1_cond_2 <- p_1_2 / p_2

# Оценим вероятность того, что Борис у Бориса будет
# дефолт при условии, что у него нет стабильной
# работы
Boris_new <- Boris
Boris_new$stable <- 0                                 # представим, что у Бориса нет  
# стабильной работы
default_li_new <- predict(model_bp2, eq = 1,          # пересчитаем оценку линейного индекса
                          newdata = Boris_new)  
p_1_n2 <- pbivnorm(x = matrix(c(default_li_new,       # вероятность притерпеть дефолт и не
                                -stable_li),          # иметь стабильной работы
                              ncol = 2),               
                   rho = -rho_est)
p_1_cond_n2 <- p_1_n2 / (1 - p_2)                     # оценка искомой условной вероятности

# Оценим предельный эффект стабильной работы
# на вероятность дефолта
ME_stable <- p_1_cond_2 - p_1_cond_n2

# ЗАДАНИЯ (* - средне, ** - сложно, *** - очень сложно)
# 3.1. Повторите задания из предыдущего раздела
#      для данной модели
# 3.2. При помощи LR теста на уровне значимости 5%
#      проверьте необходимость использования
#      иерархической модели

#---------------------------------------------------
# Часть 4. Использование копул в системах
#          бинарных уравнений
#---------------------------------------------------

# Оценим еще две модели, предполагая, что у второй
# случайной ошибки логистическое распределение
# и рассматривая различные типы связи между случайными
# ошибками за счет копулы
# Клейтона
model_bp_1 <- gjrm(formula = list(default_formula,
                                  stable_formula),
                   data = h,
                   Model = "B",
                   
                   margins = c("probit",                      # в первом уравнении распределение случайной
                               "logit"),                      # ошибки будет нормальным, а во втором - логистическим
                   BivD = "C0")                               # выбираем копулу Клейтона
summary(model_bp_1)
# Гумбеля
model_bp_2 <- gjrm(formula = list(default_formula,
                                  stable_formula),
                   data = h,
                   Model = "B",
                   
                   margins = c("probit", "logit"),            # выбираем маржинальные распределения
                   BivD = "G0")                               # выбираем копулу Гумбеля
summary(model_bp_2)

# Сравним модели по AIC
data.frame("Gaussian" = AIC(model_bp),
           "Clayton" = AIC(model_bp_1),
           "Gumbel" = AIC(model_bp_2))

# Таблицу с копулами и их описанием можно найти в:
# Marra G, Wyszynski K (2016), Semi-Parametric Copula Sample Selection Models for 
# Count Responses. Computational Statistics and Data Analysis, 104, 110-129.
# Другие работы авторов, связанные с пакетом GJRM
citation("GJRM")